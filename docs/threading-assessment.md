# MyToolWindowControl Threading Assessment

## Async `void` handlers
- CLI stream dispatch (`ToolWindows/MyToolWindowControl.xaml.cs:813`, `:893`, `:1029`, `:1105`, `:1545`): `HandleAgentMessageDelta`, `HandleAgentMessage`, `HandleTokenCount`, `HandleStreamError`, and `HandleTaskComplete` are invoked from the synchronous `HandleStdout` switch. They must remain `void` until the event dispatcher is rewritten to await `Task`-returning handlers; each method immediately marshals to the UI thread and wraps work in `try/catch` to avoid unobserved failures.
- Diff and patch events (`ToolWindows/MyToolWindowControl.xaml.cs:1241`, `:1409`, `:1473`, `:3609`): `HandleApplyPatchApproval`, `HandlePatchApplyBegin`, `HandlePatchApplyEnd`, and the UI affordance `OnDiscardPatchClick` share the same dispatcher constraints and drive UI plus CLI responses, justifying temporary `async void` usage.
- Exec pipeline (`ToolWindows/MyToolWindowControl.Exec.cs:18`, `:67`, `:127`, `:163`, `ToolWindows/MyToolWindowControl.xaml.cs:5169`, `:5297`, `:5429`, `:6555`): CLI notifications (`HandleExecApproval`, `HandleExecCommandBegin`, `HandleExecCommandOutputDelta`, `HandleExecCommandEnd`) and related UI commands (`OnExecCancelClick`, `OnExecCopyAllClick`, `OnExecClearClick`, `OnExecExportClick`) are wired through event delegates that require `void`. Conversion should happen alongside a view-model rewrite that can expose `Task` commands.
- MCP tool events (`ToolWindows/MyToolWindowControl.Mcp.cs:19`, `:42`, `:69`, `:97`, `:122`, `:152`) feed ObservableCollections used by the UI. The stdout dispatcher currently requires `async void`; future refactor should introduce a mediator that awaits these handlers.
- Authentication and approvals (`ToolWindows/MyToolWindowControl.Authentication.cs:120`, `:161`, `:202`, `ToolWindows/MyToolWindowControl.Approvals.cs:17`) are triggered by WPF button events or host stderr callbacks whose signatures are fixed (`RoutedEventHandler`, `Action<string>`), so `async void` is appropriate until commands/view-models replace the handlers.
- Transcript actions (`ToolWindows/MyToolWindowControl.Transcript.cs:18`, `ToolWindows/MyToolWindowControl.xaml.cs:9475`, `:12123`) – `OnCopyAllClick`, `OnCopyMessageMenuItemClick`, and `OnSendClick` – are WPF handlers that must remain `void` until converted to command bindings.

## ThreadHelper usage and contexts
- UI updates always route through `ThreadHelper.JoinableTaskFactory.SwitchToMainThreadAsync()` before manipulating controls (e.g., `RefreshAuthUiAsync` in `ToolWindows/MyToolWindowControl.Authentication.cs:30`, `DisplayNextApprovalAsync` in `ToolWindows/MyToolWindowControl.Approvals.cs:72`, `HandleExecCommandBegin` in `ToolWindows/MyToolWindowControl.Exec.cs:67`).
- DTE/VSSDK calls such as `ResolveWorkingDirectoryAsync` (`ToolWindows/MyToolWindowControl.WorkingDirectory.cs:34`) and `GetSolutionServiceAsync` (`ToolWindows/MyToolWindowControl.WorkingDirectory.Environment.cs:26`) switch or assert main-thread access via `ThreadHelper.ThrowIfNotOnUIThread()` (`ToolWindows/MyToolWindowControl.WorkingDirectory.Environment.cs:138`).
- Fire-and-forget launches use `ThreadHelper.JoinableTaskFactory.RunAsync` for CLI fetches and banner refreshes (`ToolWindows/MyToolWindowControl.xaml.cs:1661`, `:1665`, `ToolWindows/MyToolWindowControl.Options.cs:87`, `ToolWindows/MyToolWindowControl.Lifecycle.cs:115`), but lack cancellation/exception reporting.
- Lifecycle wiring leverages `ThreadHelper.JoinableTaskFactory.Run` in `OnLoaded` (`ToolWindows/MyToolWindowControl.Lifecycle.cs:60`) and uses `RunAsync` to detach resources on unload (`ToolWindows/MyToolWindowControl.Lifecycle.cs:122`). Consolidating thread switching behind a dispatcher abstraction would reduce repetition and centralize error handling.

## Background work better suited for services
- CLI command orchestration lives in the control: `SendUserInputAsync` (`ToolWindows/MyToolWindowControl.xaml.cs:12179`), `SendExecCancelAsync` (`ToolWindows/MyToolWindowControl.xaml.cs:12387`), and approval submissions in `ResolveActiveApprovalAsync` (`ToolWindows/MyToolWindowControl.Approvals.cs:114`). These should move behind a dedicated Codex CLI host service.
- Resource refresh routines `RequestMcpToolsAsync` (`ToolWindows/MyToolWindowControl.xaml.cs:7843`) and `RequestCustomPromptsAsync` (`ToolWindows/MyToolWindowControl.xaml.cs:7971`) run on background tasks but remain embedded in the view. A services layer could manage throttling, caching, and retry.
- Heartbeat transmission `SendHeartbeatAsync` (`ToolWindows/MyToolWindowControl.Heartbeat.cs:159`) executes from a timer callback; encapsulating it inside a connectivity service would simplify lifecycle management and cancellation.
- Workspace monitoring + restart (`EnsureWorkingDirectoryUpToDateAsync` in `ToolWindows/MyToolWindowControl.WorkingDirectory.Subscriptions.cs:108`, `RestartCliAsync` in `ToolWindows/MyToolWindowControl.xaml.cs:737`) mix DTE access with process control; refactoring into workspace and host services would clarify ownership and threading.
- Diff application and file edits (`ApplySelectedDiffsAsync` in `ToolWindows/MyToolWindowControl.xaml.cs:4065`, `ApplyDocumentTextAsync` in `ToolWindows/MyToolWindowControl.xaml.cs:4473`, `ProcessDiffDocumentsAsync` in `ToolWindows/MyToolWindowControl.Mcp.cs:232`) should shift to a diff service that can handle file IO off the UI thread and expose progress updates safely.

## Shared collections without intrinsic synchronization
- Dictionaries backing transcript/exec state (`_assistantTurns` in `ToolWindows/MyToolWindowControl.xaml.cs:189`, `_execTurns` in `ToolWindows/MyToolWindowControl.xaml.cs:193`) and the exec console buffer (`_execConsoleTurns` in `ToolWindows/MyToolWindowControl.xaml.cs:197`) assume UI-thread confinement. Concurrent host restarts (`ToolWindows/MyToolWindowControl.xaml.cs:737`) clear these collections without locks, risking races.
- Approval caches `_rememberedExecApprovals` (`ToolWindows/MyToolWindowControl.xaml.cs:221`), `_rememberedPatchApprovals` (`ToolWindows/MyToolWindowControl.xaml.cs:225`), and queue `_approvalQueue` (`ToolWindows/MyToolWindowControl.xaml.cs:229`) are mutated from multiple async contexts (e.g., `RestartCliAsync`, `EnqueueApprovalRequest` in `ToolWindows/MyToolWindowControl.Approvals.cs:65`) with no synchronization beyond implied UI access.
- Diff and MCP stores (`_diffTreeRoots` in `ToolWindows/MyToolWindowControl.xaml.cs:401`, `_diffDocuments` in `ToolWindows/MyToolWindowControl.xaml.cs:405`, `_mcpTools` in `ToolWindows/MyToolWindowControl.xaml.cs:201`, `_customPrompts` in `ToolWindows/MyToolWindowControl.xaml.cs:205`) require dispatcher confinement; any future off-thread data loading must publish immutable snapshots instead of touching these collections directly.
- `TelemetryTracker` maintains `_execStarts` (`ToolWindows/MyToolWindowControl.Telemetry.cs:19`) without locks; ensure exec lifecycle messages stay serialized on a single thread or add synchronization when moving to services.

## Heartbeat timer assessment
- `StartHeartbeatTimer` replaces `_heartbeatTimer` under `_heartbeatLock` (`ToolWindows/MyToolWindowControl.Heartbeat.cs:48`) and disposes the old timer outside the lock. Coupled with `StopHeartbeatTimer` (`ToolWindows/MyToolWindowControl.Heartbeat.cs:88`), there is a narrow race where callbacks may run after disposal; current guards (`_heartbeatSending`) mitigate but a cancellation token would be safer.
- `OnHeartbeatTimer` (`ToolWindows/MyToolWindowControl.Heartbeat.cs:127`) schedules `SendHeartbeatAsync` via `RunAsync` without awaiting results, so failures only surface through diagnostics logging.
- Host disposal (`DisposeHost` in `ToolWindows/MyToolWindowControl.xaml.cs:689`) calls `StopHeartbeatTimer`, yet callbacks queued just before disposal may still observe the old `_host`. They catch `ObjectDisposedException`, but a dedicated heartbeat service with explicit stop tokens would remove the window entirely.

## UI access requirements post-refactor
- Authentication banner and buttons manipulated in `RefreshAuthUiAsync` (`ToolWindows/MyToolWindowControl.Authentication.cs:30`) require dispatcher execution.
- Approval banner rendering (`ToolWindows/MyToolWindowControl.Approvals.cs:95`) and diff tree updates (`ToolWindows/MyToolWindowControl.Mcp.cs:189`) touch WPF elements directly; future view-models should expose binding-friendly state and perform UI updates via dispatcher adapters.
- Transcript and exec rendering routines (`AppendAssistantText` in `ToolWindows/MyToolWindowControl.xaml.cs:9223`, `AppendExecText` in `ToolWindows/MyToolWindowControl.xaml.cs:10505`) must stay on the UI thread. Extracting them into view-model observables would allow the view to subscribe via `ObservableCollection` on dispatcher contexts.
- Tool selectors and status messages (`InitializeSelectorsAsync` in `ToolWindows/MyToolWindowControl.Options.cs:16`, `VS.StatusBar.ShowMessageAsync` usage in `ToolWindows/MyToolWindowControl.Exec.cs:47`) also demand UI context; encapsulate interactions behind a small UI services layer.

## Scheduler recommendations
- Introduce a serialized CLI event processor (e.g., queue consumed by a hosted service) so stdout handlers (`ToolWindows/MyToolWindowControl.xaml.cs:1629`) can return immediately while work continues on a dedicated background scheduler.
- Wrap `ThreadHelper.JoinableTaskFactory.SwitchToMainThreadAsync()` in an `IUiDispatcher` abstraction to reduce direct dependencies and centralize error handling for UI marshaling.
- Use `JoinableTaskFactory` collections or an `AsyncLock` when performing DTE operations (`ToolWindows/MyToolWindowControl.WorkingDirectory.cs:34`) to prevent reentrancy while maintaining responsiveness.
- Replace the raw `Timer` heartbeat with a cooperative async loop managed by the CLI service to improve cancellation semantics and host state awareness.
- Run diff parsing (`ToolWindows/MyToolWindowControl.Mcp.cs:232`) and file IO on `TaskScheduler.Default`, returning immutable models to the UI thread.

## CLI reconnect path risks
- `RestartCliAsync` (`ToolWindows/MyToolWindowControl.xaml.cs:737`) lacks mutual exclusion; login/logout (`ToolWindows/MyToolWindowControl.Authentication.cs:120`, `:161`) and workspace refresh (`ToolWindows/MyToolWindowControl.WorkingDirectory.Subscriptions.cs:108`) can race. Guard lifecycle transitions with an `AsyncLock` and expose host state to the UI.
- `EnsureWorkingDirectoryUpToDateAsync` switches to the UI while holding `_workingDirLock` (`ToolWindows/MyToolWindowControl.WorkingDirectory.Subscriptions.cs:129`), preventing concurrent updates but leaving `_host` accessible to other handlers during restart. Broadcasting a "restarting" state would allow UI to gate new sends.
- `DisposeHost` (`ToolWindows/MyToolWindowControl.xaml.cs:689`) clears collections like `_assistantTurns` and `_approvalQueue` (`ToolWindows/MyToolWindowControl.xaml.cs:1933`, `:1953`) without coordination with CLI callbacks still in flight. Refactor should ensure stdout processing drains before disposing.
- `_cliStarted` (`ToolWindows/MyToolWindowControl.xaml.cs:585`) is a simple flag; converting to an atomic state enum would help consumers avoid stale reads during asynchronous transitions.
- `TryReconnectAsync` (`Core/CodexCliHost.cs:202`) restarts the process on I/O failure without notifying the tool window, so UI-layer restarts can conflict with host-level reconnect attempts. Expose reconnect state and coordinate it through the planned CLI service.

## Logging and telemetry safety
- Logging helpers (`LogTelemetryAsync` in `ToolWindows/MyToolWindowControl.xaml.cs:12727`, `WriteExecDiagnosticsAsync` in `ToolWindows/MyToolWindowControl.xaml.cs:12791`) call `DiagnosticsPane.GetAsync` from background contexts. Confirm the pane is thread-safe or funnel through a logger service that serializes writes.
- `HandleStderr` (`ToolWindows/MyToolWindowControl.Authentication.cs:202`) and exec/approval handlers perform fire-and-forget logging; a centralized logging abstraction could capture context and consolidate error handling.
- `TelemetryTracker` (`ToolWindows/MyToolWindowControl.Telemetry.cs:10`) stores mutable counters without locks. Ensure all telemetry updates remain on the UI dispatcher or add synchronization before moving to shared services.
- `WriteThrottledAsync` (`Core/CodexCliHost.cs:492`) throttles logs with static counters that are updated from multiple Task.Run pumps; make the throttling state thread-safe or move it behind a logger scoped to the CLI service.

## Risk summary
MyToolWindowControl currently relies on pervasive manual UI-thread marshaling, shared mutable dictionaries, and fire-and-forget tasks. Consolidating CLI interactions, heartbeat management, and workspace updates into dedicated services—each exposing thread-safe, awaitable APIs—will reduce the reliance on `async void` handlers and unsynchronized collections. Introducing dispatcher and host lifecycle abstractions is critical to prevent race conditions during CLI restarts, while a centralized logging/telemetry pipeline will keep background failures observable.
